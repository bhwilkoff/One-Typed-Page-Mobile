<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>One Typed Page - Mobile Reader</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/5.1.1/tesseract.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            touch-action: manipulation;
        }

        .app-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .header {
            background: rgba(0, 0, 0, 0.9);
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
            z-index: 1000;
        }

        .header.hidden {
            transform: translateY(-100%);
            transition: transform 0.3s ease;
        }

        .logo {
            font-size: 18px;
            font-weight: bold;
        }

        .controls {
            display: flex;
            gap: 10px;
        }

        .btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .main-content {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        .viewer {
            width: 100%;
            height: 100%;
            position: relative;
            display: flex;
            transition: transform 0.3s ease;
        }

        .post-container {
            width: 100%;
            height: 100%;
            flex-shrink: 0;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .image-view {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
            /* Enable native mobile zoom/pan */
            touch-action: pinch-zoom;
        }

        .post-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
            user-select: none;
            /* Allow native mobile zoom */
            touch-action: pinch-zoom;
        }

        .post-image.placeholder-image {
            opacity: 0.7;
            filter: grayscale(50%);
        }

        .text-view {
            width: 100%;
            height: 100%;
            padding: 20px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.8);
            display: none;
        }

        .text-view.active {
            display: block;
        }

        .text-content {
            max-width: 600px;
            margin: 0 auto;
            line-height: 1.6;
            font-size: 16px;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .navigation {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 12px;
            border-radius: 25px;
            backdrop-filter: blur(10px);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .navigation.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .nav-btn {
            width: 36px;
            height: 36px;
            border-radius: 18px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.2s ease;
        }

        .nav-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .nav-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 100px;
        }

        .nav-mode-toggle {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-bottom: 2px;
        }

        .nav-mode-toggle:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .nav-indicator {
            color: rgba(255, 255, 255, 0.9);
            font-size: 11px;
            text-align: center;
            font-weight: 500;
        }

        .view-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 20px;
            padding: 5px;
            display: flex;
            backdrop-filter: blur(10px);
            transition: opacity 0.3s ease;
        }

        .view-toggle.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .toggle-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 15px;
            background: transparent;
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 14px;
        }

        .toggle-btn.active {
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }

        .hide-ui-hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.7);
            color: rgba(255, 255, 255, 0.8);
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            backdrop-filter: blur(10px);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 50;
        }

        .hide-ui-hint.show {
            opacity: 1;
        }

        .error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            padding: 20px;
            background: rgba(255, 0, 0, 0.1);
            border: 1px solid rgba(255, 0, 0, 0.3);
            border-radius: 10px;
            max-width: 80%;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: rgba(20, 20, 20, 0.95);
            padding: 20px;
            border-radius: 10px;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            backdrop-filter: blur(20px);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .close-btn {
            background: none;
            border: none;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
        }

        .markdown-content {
            font-family: monospace;
            font-size: 14px;
            line-height: 1.5;
            white-space: pre-wrap;
            max-height: 70vh;
            overflow-y: auto;
        }

        /* Touch-friendly improvements */
        @media (max-width: 768px) {
            .header {
                padding: 8px 12px;
            }
            
            .logo {
                font-size: 16px;
            }
            
            .btn {
                padding: 6px 10px;
                font-size: 12px;
            }
            
            .text-view {
                padding: 15px;
            }
            
            .text-content {
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <header class="header" id="header">
            <div class="logo">One Typed Page</div>
            <div class="controls">
                <button class="btn" onclick="refreshData()" id="refreshBtn">Refresh</button>
                <button class="btn" onclick="downloadImage()">‚¨á Save</button>
                <button class="btn" onclick="exportMarkdown()">MD</button>
            </div>
        </header>

        <main class="main-content">
            <div class="viewer" id="viewer">
                <!-- Posts will be dynamically loaded here -->
            </div>

            <div class="view-toggle" id="viewToggle">
                <button class="toggle-btn active" onclick="setView('image')">Image</button>
                <button class="toggle-btn" onclick="setView('text')">Text</button>
            </div>

            <div class="hide-ui-hint" id="hideUIHint">Tap image to hide UI</div>

            <div class="navigation" id="navigation">
                <button class="nav-btn" onclick="navigateLeft()" id="leftBtn">‚Äπ</button>
                <div class="nav-info">
                    <button class="nav-mode-toggle" onclick="toggleNavMode()" id="navModeToggle">PAGES</button>
                    <div class="nav-indicator" id="navIndicator">Loading...</div>
                </div>
                <button class="nav-btn" onclick="navigateRight()" id="rightBtn">‚Ä∫</button>
            </div>

            <div class="loading" id="loading">
                <div class="spinner"></div>
                <div>Loading One Typed Page posts...</div>
            </div>
        </main>
    </div>

    <!-- Markdown Export Modal -->
    <div class="modal" id="markdownModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Markdown Export</h3>
                <button class="close-btn" onclick="closeModal()">&times;</button>
            </div>
            <div class="markdown-content" id="markdownContent"></div>
        </div>
    </div>

    <script>
        // Global state
        let allPosts = []; // All posts from RSS feed
        let currentDayIndex = 0; // Which day we're viewing (0 = today, 1 = yesterday, etc.)
        let currentPageIndex = 0; // Which page within that day
        let currentView = 'image';
        let isLoading = false;
        let ocrCache = new Map();
        let navigationMode = 'pages'; // 'pages' or 'days'
        let uiVisible = true;

        // === LOAD ALL POSTS FROM RSS FEED ===
        async function loadPosts() {
            console.log('üî• Loading all posts from RSS feed');
            const loading = document.getElementById('loading');
            const navigation = document.getElementById('navigation');
            
            try {
                loading.style.display = 'block';
                navigation.classList.add('hidden');
                
                console.log('=== Starting RSS Feed Load ===');
                const rssUrl = 'https://onetypedpage.com/feed/';
                
                const corsProxyList = [
                    'https://corsproxy.io/?',
                    'https://api.allorigins.win/raw?url=',
                    'https://corsproxy.org/?',
                    'https://cors.bridged.cc/',
                    'https://api.codetabs.com/v1/proxy?quest=',
                    'https://cors-fix.vercel.app/api/cors?url=',
                    'https://thingproxy.freeboard.io/fetch/',
                    'https://api.allorigins.win/get?url=',
                    'https://crossorigin.me/'
                ];
                
                let successfulResponse = null;
                
                // Test each proxy service
                for (let i = 0; i < corsProxyList.length; i++) {
                    const proxyUrl = corsProxyList[i];
                    console.log(`\n[${i + 1}/${corsProxyList.length}] Testing: ${proxyUrl}`);
                    
                    try {
                        const fullUrl = proxyUrl + encodeURIComponent(rssUrl);
                        
                        const fetchResponse = await fetch(fullUrl, {
                            method: 'GET',
                            headers: {
                                'User-Agent': 'Mozilla/5.0 (compatible; RSS Reader)',
                                'Accept': 'application/rss+xml, application/xml, text/xml, */*'
                            }
                        });
                        
                        console.log(`Response: ${fetchResponse.status} ${fetchResponse.statusText}`);
                        
                        if (fetchResponse.ok) {
                            let textContent;
                            
                            if (proxyUrl.includes('allorigins.win/get')) {
                                const jsonResponse = await fetchResponse.json();
                                textContent = jsonResponse.contents;
                            } else {
                                textContent = await fetchResponse.text();
                            }
                            
                            console.log(`Content length: ${textContent.length} characters`);
                            
                            if (textContent.includes('<?xml') || textContent.includes('<rss') || textContent.includes('<feed')) {
                                console.log('‚úÖ Valid RSS/XML content detected!');
                                successfulResponse = textContent;
                                break;
                            }
                        }
                    } catch (fetchError) {
                        console.log(`‚ùå Proxy failed: ${fetchError.message}`);
                    }
                }
                
                if (!successfulResponse) {
                    console.log('üîß All proxies failed - showing manual input option');
                    showManualInput();
                    loading.style.display = 'none';
                    return;
                }
                
                // Parse the RSS response
                console.log('\n=== Parsing RSS Content ===');
                const xmlParser = new DOMParser();
                const rssDocument = xmlParser.parseFromString(successfulResponse, 'text/xml');
                
                const parserError = rssDocument.querySelector('parsererror');
                if (parserError) {
                    throw new Error('XML Parser Error: ' + parserError.textContent);
                }
                
                // Get ALL RSS items (not just the first one)
                const rssItems = rssDocument.querySelectorAll('item');
                console.log(`Found ${rssItems.length} RSS items`);
                
                if (rssItems.length === 0) {
                    throw new Error('No RSS items found in feed');
                }
                
                // Process ALL posts from the feed
                allPosts = [];
                
                for (let i = 0; i < Math.min(rssItems.length, 10); i++) { // Limit to 10 most recent
                    const item = rssItems[i];
                    const postTitle = item.querySelector('title')?.textContent || `Post ${i + 1}`;
                    const postLink = item.querySelector('link')?.textContent || '';
                    const postDate = item.querySelector('pubDate')?.textContent || '';
                    
                    // Get post content
                    let postContent = '';
                    const contentSources = [
                        item.querySelector('description')?.textContent || '',
                        item.querySelector('content\\:encoded')?.textContent || '',
                        item.querySelector('content')?.textContent || '',
                        item.querySelector('summary')?.textContent || '',
                        item.innerHTML || ''
                    ];
                    
                    for (const source of contentSources) {
                        if (source && source.trim().length > 0) {
                            postContent = source;
                            break;
                        }
                    }
                    
                    console.log(`\n=== Processing Post ${i + 1}: ${postTitle} ===`);
                    
                    // Extract images from this post
                    const extractedImages = [];
                    const imagePatterns = [
                        /<img[^>]+src=["']([^"']+)["']/gi,
                        /src=["']([^"']+\.(?:jpg|jpeg|png|gif|webp))["']/gi,
                        /https?:\/\/[^"\s<>]+\.(?:jpg|jpeg|png|gif|webp)/gi,
                        /https?:\/\/[^"\s<>]+\/wp-content\/uploads\/[^"\s<>]*\.(?:jpg|jpeg|png|gif|webp)/gi,
                        /https?:\/\/[^"\s<>]*\.(?:jpg|jpeg|png|gif|webp)\?[^"\s<>]*/gi,
                        /data:image\/[^;]+;base64,[^"\s<>]+/gi
                    ];
                    
                    for (const pattern of imagePatterns) {
                        const matches = [...postContent.matchAll(pattern)];
                        matches.forEach((match) => {
                            let imageUrl = match[1] || match[0];
                            imageUrl = imageUrl.replace(/^["'(]+|["')]+$/g, '').trim();
                            
                            if (imageUrl && !extractedImages.includes(imageUrl)) {
                                extractedImages.push(imageUrl);
                            }
                        });
                    }
                    
                    // Deduplicate images
                    const deduplicatedImages = [];
                    const imageGroups = new Map();
                    
                    extractedImages.forEach((url) => {
                        let baseFilename = url.split('/').pop();
                        baseFilename = baseFilename.split('?')[0];
                        baseFilename = baseFilename.replace(/-\d+x\d+/, '');
                        baseFilename = baseFilename.replace(/-scaled/, '');
                        
                        if (!imageGroups.has(baseFilename)) {
                            imageGroups.set(baseFilename, []);
                        }
                        imageGroups.get(baseFilename).push(url);
                    });
                    
                    imageGroups.forEach((versions) => {
                        let bestVersion = versions[0];
                        for (const version of versions) {
                            if (!version.match(/-\d+x\d+/) && bestVersion.match(/-\d+x\d+/)) {
                                bestVersion = version;
                            }
                        }
                        deduplicatedImages.push(bestVersion);
                    });
                    
                    console.log(`Found ${deduplicatedImages.length} images for this post`);
                    
                    // Create post data
                    const postData = {
                        title: postTitle,
                        link: postLink,
                        description: postContent,
                        pubDate: postDate,
                        dayIndex: i, // 0 = today, 1 = yesterday, etc.
                        images: deduplicatedImages.length > 0 ? deduplicatedImages : ['https://via.placeholder.com/600x800/333/fff?text=No+Images+Found']
                    };
                    
                    allPosts.push(postData);
                }
                
                console.log(`\n‚úÖ Loaded ${allPosts.length} posts total`);
                
                // Start with today's post
                currentDayIndex = 0;
                currentPageIndex = 0;
                
                renderCurrentPost();
                loading.style.display = 'none';
                navigation.classList.remove('hidden');
                updateNavigation();
                showUIHint();
                
            } catch (overallError) {
                console.error('üí• Complete failure:', overallError);
                showError(`Failed to load RSS feed: ${overallError.message}\n\nTry the manual input option below.`);
                loading.style.display = 'none';
            }
        }

        // Show manual RSS input when all proxies fail
        function showManualInput() {
            const viewer = document.getElementById('viewer');
            viewer.innerHTML = `
                <div class="error-message">
                    <h3>üîß Manual RSS Input</h3>
                    <p>All CORS proxies failed. Please paste the RSS feed content manually:</p>
                    <ol style="text-align: left; margin: 15px 0;">
                        <li>Visit <a href="https://onetypedpage.com/feed/" target="_blank" style="color: #66c0f4;">https://onetypedpage.com/feed/</a></li>
                        <li>Copy all the XML content (Ctrl+A, Ctrl+C)</li>
                        <li>Paste it in the text area below</li>
                        <li>Click "Load from Pasted Content"</li>
                    </ol>
                    <textarea id="manualRSSInput" placeholder="Paste RSS XML content here..." 
                              style="width: 100%; height: 200px; background: rgba(255,255,255,0.1); color: #fff; border: 1px solid rgba(255,255,255,0.3); border-radius: 5px; padding: 10px; font-family: monospace; font-size: 12px; resize: vertical;"></textarea>
                    <div style="margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;">
                        <button class="btn" onclick="loadFromManualInput()">Load from Pasted Content</button>
                        <button class="btn" onclick="window.loadSampleData()">Load Sample Data Instead</button>
                        <button class="btn" onclick="refreshData()">Try Auto-Load Again</button>
                    </div>
                </div>
            `;
            
            // Setup tap-to-hide functionality for the new image
            setupImageTapToHide();
        }

        // Load RSS from manually pasted content
        function loadFromManualInput() {
            // Similar to loadPosts() but for manual input
            // Implementation would be similar to above but processing pasted content
            alert('Manual input functionality would be implemented here');
        }

        // Render the current post based on current indices
        function renderCurrentPost() {
            const viewer = document.getElementById('viewer');
            
            if (allPosts.length === 0 || currentDayIndex >= allPosts.length) {
                viewer.innerHTML = '<div class="error-message">No posts available</div>';
                return;
            }
            
            const currentPost = allPosts[currentDayIndex];
            const currentImage = currentPost.images[currentPageIndex] || currentPost.images[0];
            
            const hasRealImage = !currentImage.includes('placeholder');
            const imageClass = hasRealImage ? 'post-image' : 'post-image placeholder-image';
            
            viewer.innerHTML = `
                <div class="post-container">
                    <div class="image-view" id="imageView">
                        ${!hasRealImage ? '<div style="position: absolute; top: 10px; left: 10px; background: rgba(255,0,0,0.7); color: white; padding: 5px 10px; border-radius: 5px; font-size: 12px; z-index: 10;">No Image Found</div>' : ''}
                        <img class="${imageClass}" 
                             src="${currentImage}" 
                             alt="${currentPost.title}"
                             onload="imageLoaded()"
                             onerror="imageError()">
                    </div>
                    <div class="text-view" id="textView">
                        <div class="text-content">
                            <h2>${currentPost.title}</h2>
                            <p><small>${new Date(currentPost.pubDate).toLocaleDateString()}</small></p>
                            <p><a href="${currentPost.link}" target="_blank" style="color: #66c0f4;">View Original Post</a></p>
                            <hr style="margin: 20px 0; border: 1px solid rgba(255,255,255,0.2);">
                            <div id="ocrContent">
                                <p><em>Click "Extract Text" to perform OCR on this image...</em></p>
                                <button class="btn" onclick="performOCR()" style="margin-top: 10px;">Extract Text</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        // Image loading handlers
        function imageLoaded() {
            console.log('Image loaded successfully');
        }

        function imageError() {
            console.error('Failed to load image');
            const imageView = document.getElementById('imageView');
            if (imageView) {
                imageView.innerHTML = '<div class="error-message">Failed to load image</div>';
            }
        }

        // Navigation functions
        function navigateLeft() {
            if (navigationMode === 'pages') {
                previousPost();
            } else {
                nextDay(); // Note: "left" goes to more recent day (lower index)
            }
        }

        function navigateRight() {
            if (navigationMode === 'pages') {
                nextPost();
            } else {
                previousDay(); // Note: "right" goes to older day (higher index)
            }
        }

        function toggleNavMode() {
            navigationMode = navigationMode === 'pages' ? 'days' : 'pages';
            updateNavigation();
        }

        function nextPost() {
            if (allPosts.length === 0) return;
            
            const currentPost = allPosts[currentDayIndex];
            if (currentPageIndex < currentPost.images.length - 1) {
                currentPageIndex++;
                renderCurrentPost();
                updateNavigation();
            }
        }

        function previousPost() {
            if (currentPageIndex > 0) {
                currentPageIndex--;
                renderCurrentPost();
                updateNavigation();
            }
        }

        function nextDay() {
            if (currentDayIndex > 0) {
                currentDayIndex--;
                currentPageIndex = 0;
                renderCurrentPost();
                updateNavigation();
            }
        }

        function previousDay() {
            if (currentDayIndex < allPosts.length - 1) {
                currentDayIndex++;
                currentPageIndex = 0;
                renderCurrentPost();
                updateNavigation();
            }
        }

        function updateNavigation() {
            const leftBtn = document.getElementById('leftBtn');
            const rightBtn = document.getElementById('rightBtn');
            const navIndicator = document.getElementById('navIndicator');
            const navModeToggle = document.getElementById('navModeToggle');

            if (allPosts.length === 0) return;

            const currentPost = allPosts[currentDayIndex];
            
            if (navigationMode === 'pages') {
                // Page navigation mode
                leftBtn.disabled = currentPageIndex === 0;
                rightBtn.disabled = currentPageIndex >= currentPost.images.length - 1;
                
                if (currentPost.images.length > 1) {
                    navIndicator.textContent = `${currentPageIndex + 1} / ${currentPost.images.length}`;
                } else {
                    navIndicator.textContent = `1 / 1`;
                }
                
                navModeToggle.textContent = 'PAGES';
                
            } else {
                // Day navigation mode
                leftBtn.disabled = currentDayIndex === 0;
                rightBtn.disabled = currentDayIndex >= allPosts.length - 1;
                
                // Calculate relative date
                const today = new Date();
                const postDate = new Date(currentPost.pubDate);
                const daysDiff = Math.floor((today - postDate) / (1000 * 60 * 60 * 24));
                
                let dayText;
                if (daysDiff === 0) {
                    dayText = 'Today';
                } else if (daysDiff === 1) {
                    dayText = 'Yesterday';
                } else {
                    dayText = `${daysDiff} Days Ago`;
                }
                
                navIndicator.textContent = dayText;
                navModeToggle.textContent = 'DAYS';
            }
        }

        // UI visibility functions
        function toggleUI() {
            uiVisible = !uiVisible;
            const header = document.getElementById('header');
            const navigation = document.getElementById('navigation');
            const viewToggle = document.getElementById('viewToggle');
            
            if (uiVisible) {
                header.classList.remove('hidden');
                navigation.classList.remove('hidden');
                viewToggle.classList.remove('hidden');
            } else {
                header.classList.add('hidden');
                navigation.classList.add('hidden');
                viewToggle.classList.add('hidden');
            }
        }

        function showUIHint() {
            const hint = document.getElementById('hideUIHint');
            hint.classList.add('show');
            setTimeout(() => {
                hint.classList.remove('show');
            }, 3000);
        }

        // Add tap-to-hide functionality to images
        function setupImageTapToHide() {
            const imageView = document.getElementById('imageView');
            if (imageView) {
                imageView.addEventListener('click', (e) => {
                    // Only toggle UI if clicking directly on the image container, not OCR buttons etc.
                    if (e.target === imageView || e.target.tagName === 'IMG') {
                        toggleUI();
                    }
                });
            }
        }

        // View toggle functions
        function setView(view) {
            const toggleBtns = document.querySelectorAll('.toggle-btn');
            
            toggleBtns.forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            currentView = view;
            
            const imageView = document.getElementById('imageView');
            const textView = document.getElementById('textView');
            
            if (view === 'image') {
                if (imageView) imageView.style.display = 'block';
                if (textView) textView.classList.remove('active');
            } else {
                if (imageView) imageView.style.display = 'none';
                if (textView) textView.classList.add('active');
            }
        }

        // Remove swipe navigation to avoid conflicts with pinch-zoom
        function setupTouchEvents() {
            // Only keyboard navigation now
            document.addEventListener('keydown', (e) => {
                switch(e.key) {
                    case 'ArrowLeft':
                        if (navigationMode === 'pages') {
                            previousPost();
                        } else {
                            nextDay();
                        }
                        break;
                    case 'ArrowRight':
                        if (navigationMode === 'pages') {
                            nextPost();
                        } else {
                            previousDay();
                        }
                        break;
                    case 'ArrowUp':
                        navigationMode = 'days';
                        updateNavigation();
                        break;
                    case 'ArrowDown':
                        navigationMode = 'pages';
                        updateNavigation();
                        break;
                    case ' ':
                        e.preventDefault();
                        toggleUI();
                        break;
                }
            });
        }

        // === OCR FUNCTIONALITY ===
        async function performOCR() {
            const ocrContent = document.getElementById('ocrContent');
            ocrContent.innerHTML = `
                <div style="background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; margin-top: 15px;">
                    <h4>üîç OCR Text Extraction Methods</h4>
                    <p style="margin: 10px 0;">Choose a fundamentally different OCR approach:</p>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 15px 0;">
                        <button class="btn" onclick="runLegacyOCR()" style="padding: 10px; font-size: 12px;">
                            üèõÔ∏è Legacy Engine<br>
                            <small style="opacity: 0.7;">Traditional character recognition</small>
                        </button>
                        <button class="btn" onclick="runNeuralOCR()" style="padding: 10px; font-size: 12px;">
                            üß† Neural LSTM<br>
                            <small style="opacity: 0.7;">Modern AI-based recognition</small>
                        </button>
                        <button class="btn" onclick="runPreprocessedOCR()" style="padding: 10px; font-size: 12px;">
                            üîß Enhanced Image<br>
                            <small style="opacity: 0.7;">Pre-processed or enhanced settings</small>
                        </button>
                        <button class="btn" onclick="runRestrictedOCR()" style="padding: 10px; font-size: 12px;">
                            üéØ Character-Limited<br>
                            <small style="opacity: 0.7;">Strict character whitelist</small>
                        </button>
                    </div>
                    
                    <div style="margin-top: 15px;">
                        <button class="btn" onclick="showCloudOCROptions()" style="background: rgba(0,150,255,0.3);">
                            ‚òÅÔ∏è Use Cloud OCR (Most Accurate)
                        </button>
                    </div>
                    
                    <div style="margin-top: 10px; padding: 10px; background: rgba(255,165,0,0.1); border-radius: 5px; font-size: 12px;">
                        üí° <strong>Tip:</strong> Each method uses a different approach to prevent character artifacts. Try Neural LSTM first for typewritten text!
                    </div>
                </div>
            `;
        }

        // Method 1: Legacy OCR Engine
        async function runLegacyOCR() {
            await runOCRWithMethod('Legacy Engine', {
                logger: createProgressLogger('Legacy Engine'),
                recognize: async (img) => {
                    return await Tesseract.recognize(img, 'eng', {
                        tessedit_ocr_engine_mode: 0,
                        tessedit_pageseg_mode: 6,
                        preserve_interword_spaces: 1,
                        tessedit_char_blacklist: 'Il|',
                        textord_min_linesize: 1.25,
                        tessedit_reject_mode: 2,
                        classify_bln_numeric_mode: 1
                    });
                }
            });
        }

        // Method 2: Neural LSTM Engine
        async function runNeuralOCR() {
            await runOCRWithMethod('Neural LSTM', {
                logger: createProgressLogger('Neural LSTM'),
                recognize: async (img) => {
                    return await Tesseract.recognize(img, 'eng', {
                        tessedit_ocr_engine_mode: 1,
                        tessedit_pageseg_mode: 3,
                        preserve_interword_spaces: 1,
                        tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.,!?;:\'\"()[]{}/-_@#$%^&*+=<>~ \n\t',
                        tessedit_reject_mode: 5,
                        classify_bln_numeric_mode: 1,
                        textord_tabfind_find_tables: 1
                    });
                }
            });
        }

        // Method 3: Enhanced Image OCR
        async function runPreprocessedOCR() {
            await runOCRWithMethod('Enhanced Image', {
                logger: createProgressLogger('Enhanced Image'),
                recognize: async (img) => {
                    try {
                        const preprocessedImage = await preprocessImage(img);
                        return await Tesseract.recognize(preprocessedImage, 'eng', {
                            tessedit_ocr_engine_mode: 1,
                            tessedit_pageseg_mode: 6,
                            preserve_interword_spaces: 1,
                            tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.,!?;:\'\"()[]{}/-_@#$%^&*+=<>~ \n\t',
                            tessedit_reject_mode: 5,
                            load_system_dawg: 1,
                            load_freq_dawg: 1
                        });
                    } catch (corsError) {
                        console.log('Image preprocessing failed due to CORS restrictions. Using enhanced Tesseract settings instead.');
                        return await Tesseract.recognize(img, 'eng', {
                            tessedit_ocr_engine_mode: 1,
                            tessedit_pageseg_mode: 6,
                            preserve_interword_spaces: 1,
                            tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.,!?;:\'\"()[]{}/-_@#$%^&*+=<>~ \n\t',
                            tessedit_reject_mode: 5,
                            load_system_dawg: 1,
                            load_freq_dawg: 1,
                            textord_debug_images: 0,
                            textord_noise_normratio: 2,
                            textord_noise_translimit: 16,
                            textord_noise_sncount: 1,
                            classify_bln_numeric_mode: 1
                        });
                    }
                }
            });
        }

        // Method 4: Character-Restricted OCR
        async function runRestrictedOCR() {
            await runOCRWithMethod('Character-Limited', {
                logger: createProgressLogger('Character-Limited'),
                recognize: async (img) => {
                    return await Tesseract.recognize(img, 'eng', {
                        tessedit_ocr_engine_mode: 1,
                        tessedit_pageseg_mode: 6,
                        preserve_interword_spaces: 1,
                        tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.,!? \n',
                        tessedit_reject_mode: 5,
                        classify_bln_numeric_mode: 1,
                        tessedit_reject_alphas_in_number_mode: 1,
                        load_system_dawg: 1,
                        load_freq_dawg: 1
                    });
                }
            });
        }

        // Image preprocessing function
        async function preprocessImage(img) {
            return new Promise((resolve, reject) => {
                try {
                    const corsImage = new Image();
                    corsImage.crossOrigin = 'anonymous';
                    
                    corsImage.onload = function() {
                        try {
                            const canvas = document.createElement('canvas');
                            const ctx = canvas.getContext('2d');
                            
                            canvas.width = corsImage.naturalWidth || corsImage.width;
                            canvas.height = corsImage.naturalHeight || corsImage.height;
                            
                            ctx.drawImage(corsImage, 0, 0, canvas.width, canvas.height);
                            
                            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                            const data = imageData.data;
                            
                            for (let i = 0; i < data.length; i += 4) {
                                const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
                                const enhanced = gray > 128 ? 255 : 0;
                                
                                data[i] = enhanced;
                                data[i + 1] = enhanced;
                                data[i + 2] = enhanced;
                            }
                            
                            ctx.putImageData(imageData, 0, 0);
                            
                            const processedImg = new Image();
                            processedImg.onload = () => resolve(processedImg);
                            processedImg.onerror = () => reject(new Error('Failed to create processed image'));
                            processedImg.src = canvas.toDataURL();
                            
                        } catch (canvasError) {
                            reject(new Error('CORS restriction prevents image preprocessing'));
                        }
                    };
                    
                    corsImage.onerror = function() {
                        reject(new Error('CORS not supported for this image'));
                    };
                    
                    corsImage.src = img.src;
                    
                } catch (error) {
                    reject(error);
                }
            });
        }

        // Create progress logger
        function createProgressLogger(methodName) {
            return (m) => {
                if (m.status === 'recognizing text') {
                    const progress = Math.round(m.progress * 100);
                    const ocrContent = document.getElementById('ocrContent');
                    if (ocrContent) {
                        ocrContent.innerHTML = `
                            <div class="loading">
                                <div class="spinner"></div>
                                <p>${methodName}: ${progress}%</p>
                                <p style="font-size: 12px;">Processing with enhanced character filtering...</p>
                            </div>
                        `;
                    }
                }
            };
        }

        // Generic OCR runner
        async function runOCRWithMethod(methodName, config) {
            const ocrContent = document.getElementById('ocrContent');
            
            try {
                const img = document.querySelector('#imageView img');
                
                await new Promise((resolve) => {
                    if (img.complete) resolve();
                    else img.onload = resolve;
                });

                console.log(`Running ${methodName} OCR...`);

                const result = await config.recognize(img);
                const extractedText = result.data.text;
                const confidence = result.data.confidence;

                const cleanedText = basicTextCleanup(extractedText);
                displayOCRResult(cleanedText, methodName, confidence);

            } catch (error) {
                console.error(`${methodName} OCR error:`, error);
                ocrContent.innerHTML = `
                    <div style="color: #ff6b6b; padding: 15px; background: rgba(255,0,0,0.1); border-radius: 8px;">
                        <h4>${methodName} OCR Failed</h4>
                        <p>${error.message}</p>
                        <button class="btn" onclick="performOCR()" style="margin-top: 10px;">Try Different Method</button>
                    </div>
                `;
            }
        }

        // Basic text cleanup
        function basicTextCleanup(text) {
            let cleaned = text;
            cleaned = cleaned.replace(/\s{2,}/g, ' ');
            cleaned = cleaned.replace(/^\s+|\s+$/g, '');
            cleaned = cleaned.replace(/\s+([,.!?;:])/g, '$1');
            cleaned = cleaned.replace(/([,.!?;:])\s*([a-zA-Z])/g, '$1 $2');
            return cleaned;
        }

        function displayOCRResult(text, methodName = 'OCR', confidence = 0) {
            const ocrContent = document.getElementById('ocrContent');
            const wordCount = text.split(/\s+/).filter(word => word.length > 0).length;
            const confidenceLevel = confidence > 70 ? 'High' : confidence > 40 ? 'Medium' : 'Low';
            
            ocrContent.innerHTML = `
                <div style="background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; margin-top: 15px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <h4>üîç ${methodName} OCR Result</h4>
                        <small style="color: rgba(255,255,255,0.7);">
                            ${wordCount} words ‚Ä¢ ${confidenceLevel} confidence
                        </small>
                    </div>
                    
                    <div style="margin: 15px 0;">
                        <div style="max-height: 200px; overflow-y: auto; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 5px; border: 1px solid rgba(255,255,255,0.1);">
                            <textarea id="ocrText" style="width: 100%; min-height: 120px; background: transparent; border: none; color: #fff; font-family: 'Courier New', monospace; font-size: 14px; line-height: 1.4; resize: vertical;" placeholder="Extracted text will appear here...">${text}</textarea>
                        </div>
                        <small style="color: rgba(255,255,255,0.6); margin-top: 5px; display: block;">
                            üí° Text is editable - fix any remaining errors manually
                        </small>
                    </div>
                    
                    <div style="display: flex; gap: 8px; flex-wrap: wrap; margin-top: 15px;">
                        <button class="btn" onclick="performOCR()" style="font-size: 12px;">
                            üîÑ Try Different Method
                        </button>
                        <button class="btn" onclick="copyOCRText()" style="font-size: 12px;">
                            üìã Copy Text
                        </button>
                        <button class="btn" onclick="downloadOCRText()" style="font-size: 12px;">
                            üíæ Save as .txt
                        </button>
                        <button class="btn" onclick="showCloudOCROptions()" style="font-size: 12px; background: rgba(0,150,255,0.3);">
                            ‚òÅÔ∏è Try Cloud OCR
                        </button>
                    </div>
                </div>
            `;
        }

        function copyOCRText() {
            const textArea = document.getElementById('ocrText');
            if (textArea) {
                const text = textArea.value;
                navigator.clipboard.writeText(text).then(() => {
                    showNotification('‚úÖ Text copied to clipboard!');
                }).catch(() => {
                    textArea.select();
                    document.execCommand('copy');
                    showNotification('‚úÖ Text copied to clipboard!');
                });
            }
        }

        function downloadOCRText() {
            const textArea = document.getElementById('ocrText');
            if (textArea && allPosts.length > 0) {
                const text = textArea.value;
                const currentPost = allPosts[currentDayIndex];
                
                const blob = new Blob([text], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `${currentPost.title.replace(/[^a-z0-9]/gi, '_')}_page_${currentPageIndex + 1}.txt`;
                link.click();
                URL.revokeObjectURL(url);
                
                showNotification('üíæ Text file downloaded!');
            }
        }

        function showCloudOCROptions() {
            const ocrContent = document.getElementById('ocrContent');
            
            ocrContent.innerHTML = `
                <div style="background: rgba(0,100,200,0.1); padding: 15px; border-radius: 8px; margin-top: 15px;">
                    <h4>üå©Ô∏è Cloud OCR Options</h4>
                    <p style="margin: 10px 0;">For the highest accuracy on typewritten text, use these professional services:</p>
                    
                    <div style="margin: 15px 0;">
                        <h5>üì± Mobile Apps (Recommended)</h5>
                        <ul style="margin: 10px 0 10px 20px;">
                            <li><strong>Adobe Scan</strong> - Free, excellent for documents</li>
                            <li><strong>Microsoft Office Lens</strong> - Great OCR accuracy</li>
                            <li><strong>Google Keep</strong> - Extract text from photos</li>
                        </ul>
                    </div>
                    
                    <div style="margin: 15px 0;">
                        <h5>üåê Online Services</h5>
                        <ul style="margin: 10px 0 10px 20px;">
                            <li><a href="https://www.onlineocr.net/" target="_blank" style="color: #66c0f4;">OnlineOCR.net</a> - Free, supports typewritten text</li>
                            <li><a href="https://www.imagetotext.info/" target="_blank" style="color: #66c0f4;">ImageToText.info</a> - Good for handwritten/typed text</li>
                            <li><a href="https://www.prepostseo.com/image-to-text" target="_blank" style="color: #66c0f4;">PrePostSEO</a> - Multiple OCR engines</li>
                        </ul>
                    </div>
                    
                    <div style="margin-top: 15px;">
                        <button class="btn" onclick="downloadImageForOCR()">üì• Download Image for Cloud OCR</button>
                        <button class="btn" onclick="performOCR()" style="margin-left: 10px;">üîÑ Try Local OCR Again</button>
                    </div>
                </div>
            `;
        }

        function downloadImageForOCR() {
            if (allPosts.length > 0) {
                const currentPost = allPosts[currentDayIndex];
                const currentImage = currentPost.images[currentPageIndex];
                
                if (currentImage) {
                    const link = document.createElement('a');
                    link.href = currentImage;
                    link.download = `typewritten-page-${currentDayIndex}-${currentPageIndex + 1}.jpg`;
                    link.click();
                    
                    showNotification('üì• Image downloaded! Upload to a cloud OCR service for best results.');
                }
            }
        }

        // Utility functions
        function refreshData() {
            allPosts = [];
            currentDayIndex = 0;
            currentPageIndex = 0;
            ocrCache.clear();
            loadPosts();
        }

        function showError(message) {
            const viewer = document.getElementById('viewer');
            viewer.innerHTML = `
                <div class="error-message">
                    <h3>‚ö†Ô∏è Error</h3>
                    <pre style="white-space: pre-wrap; font-family: inherit; margin-top: 10px;">${message}</pre>
                    <div style="margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;">
                        <button class="btn" onclick="refreshData()">Try Again</button>
                        <button class="btn" onclick="window.loadSampleData()">Load Sample Data</button>
                    </div>
                </div>
            `;
        }

        // Fixed download function for mobile
        function downloadImage() {
            if (allPosts.length > 0) {
                const currentPost = allPosts[currentDayIndex];
                const currentImage = currentPost.images[currentPageIndex];
                
                if (currentImage && !currentImage.includes('placeholder')) {
                    // Create download link
                    const link = document.createElement('a');
                    link.href = currentImage;
                    link.download = `one-typed-page-${currentDayIndex}-${currentPageIndex + 1}.jpg`;
                    
                    // For mobile devices, try to trigger actual download
                    if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
                        // Mobile: Open in new tab and let user save manually
                        window.open(currentImage, '_blank');
                        showNotification('üì± Image opened in new tab. Use your browser\'s save option to download.');
                    } else {
                        // Desktop: Trigger download
                        link.click();
                        showNotification('üíæ Image download started!');
                    }
                } else {
                    showNotification('‚ùå No image available to download');
                }
            }
        }

        function exportMarkdown() {
            let markdown = '# One Typed Page Collection\n\n';
            
            allPosts.forEach((post, dayIndex) => {
                const today = new Date();
                const postDate = new Date(post.pubDate);
                const daysDiff = Math.floor((today - postDate) / (1000 * 60 * 60 * 24));
                
                let dayText;
                if (daysDiff === 0) {
                    dayText = 'Today';
                } else if (daysDiff === 1) {
                    dayText = 'Yesterday';
                } else {
                    dayText = `${daysDiff} Days Ago`;
                }
                
                markdown += `## ${dayText} - ${post.title}\n\n`;
                markdown += `**Date:** ${new Date(post.pubDate).toLocaleDateString()}\n\n`;
                markdown += `**Original Link:** [View Post](${post.link})\n\n`;
                
                post.images.forEach((image, imageIndex) => {
                    if (!image.includes('placeholder')) {
                        markdown += `**Image ${imageIndex + 1}:** ![${post.title} - Page ${imageIndex + 1}](${image})\n\n`;
                    }
                });
                
                markdown += '---\n\n';
            });

            document.getElementById('markdownContent').textContent = markdown;
            document.getElementById('markdownModal').classList.add('active');
        }

        function closeModal() {
            document.getElementById('markdownModal').classList.remove('active');
        }

        function showNotification(message) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed; top: 20px; right: 20px; 
                background: rgba(0,0,0,0.8); color: white; 
                padding: 10px 15px; border-radius: 5px; 
                z-index: 9999; font-size: 14px;
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255,255,255,0.2);
            `;
            notification.textContent = message;
            document.body.appendChild(notification);
            setTimeout(() => {
                if (document.body.contains(notification)) {
                    document.body.removeChild(notification);
                }
            }, 3000);
        }

        // Sample data function
        window.loadSampleData = function() {
            console.log('Loading sample data for testing...');
            allPosts = [
                {
                    title: "Sample Post - Today",
                    link: "https://onetypedpage.com/sample1",
                    description: "Today's sample post",
                    pubDate: new Date().toISOString(),
                    dayIndex: 0,
                    images: [
                        "https://via.placeholder.com/600x800/333/fff?text=Today+Page+1",
                        "https://via.placeholder.com/600x800/444/fff?text=Today+Page+2"
                    ]
                },
                {
                    title: "Sample Post - Yesterday",
                    link: "https://onetypedpage.com/sample2", 
                    description: "Yesterday's sample post",
                    pubDate: new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString(),
                    dayIndex: 1,
                    images: [
                        "https://via.placeholder.com/600x800/555/fff?text=Yesterday+Page+1"
                    ]
                }
            ];
            
            currentDayIndex = 0;
            currentPageIndex = 0;
            
            const loading = document.getElementById('loading');
            const navigation = document.getElementById('navigation');
            
            renderCurrentPost();
            loading.style.display = 'none';
            navigation.classList.remove('hidden');
            updateNavigation();
            
            console.log('Sample data loaded!');
        };

        // Make manual input function globally available
        window.loadFromManualInput = loadFromManualInput;

        // Initialize the app
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üöÄ One Typed Page Mobile Viewer v5.1 - STREAMLINED NAVIGATION');
            console.log('Features: Combined navigation, tap-to-hide UI, mobile-optimized interface');
            setupTouchEvents();
            loadPosts();
        });

        // Hide UI on inactivity (mobile-friendly)
        let hideTimeout;
        function resetHideTimeout() {
            if (!uiVisible) return; // Don't reset if UI is manually hidden
            
            clearTimeout(hideTimeout);
            const header = document.getElementById('header');
            const navigation = document.getElementById('navigation');
            const viewToggle = document.getElementById('viewToggle');
            
            // Show UI
            header.classList.remove('hidden');
            navigation.classList.remove('hidden');
            viewToggle.classList.remove('hidden');
            
            hideTimeout = setTimeout(() => {
                // Only auto-hide if in image view on mobile and UI is still supposed to be visible
                if (currentView === 'image' && window.innerWidth <= 768 && uiVisible) {
                    header.classList.add('hidden');
                    navigation.classList.add('hidden');
                    viewToggle.classList.add('hidden');
                }
            }, 4000);
        }

        document.addEventListener('touchstart', resetHideTimeout);
        document.addEventListener('mousemove', resetHideTimeout);
        document.addEventListener('click', resetHideTimeout);
    </script>
</body>
</html>